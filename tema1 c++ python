c++ 
#include <iostream>
#include <cmath>

using namespace std;

// Структура для представления комплексного числа
struct ComplexNumber {
    double real; // Действительная часть
    double imag; // Мнимая часть
};

// Функция для сложения комплексных чисел
ComplexNumber addComplexNumbers(ComplexNumber z1, ComplexNumber z2) {
    ComplexNumber result;
    result.real = z1.real + z2.real;
    result.imag = z1.imag + z2.imag;
    return result;
}

// Функция для вычитания комплексных чисел
ComplexNumber subtractComplexNumbers(ComplexNumber z1, ComplexNumber z2) {
    ComplexNumber result;
    result.real = z1.real - z2.real;
    result.imag = z1.imag - z2.imag;
    return result;
}

// Функция для умножения комплексных чисел
ComplexNumber multiplyComplexNumbers(ComplexNumber z1, ComplexNumber z2) {
    ComplexNumber result;
    result.real = z1.real * z2.real - z1.imag * z2.imag;
    result.imag = z1.real * z2.imag + z1.imag * z2.real;
    return result;
}

// Функция для деления комплексных чисел
ComplexNumber divideComplexNumbers(ComplexNumber z1, ComplexNumber z2) {
    ComplexNumber result;
    double denominator = z2.real * z2.real + z2.imag * z2.imag;
    result.real = (z1.real * z2.real + z1.imag * z2.imag) / denominator;
    result.imag = (z1.imag * z2.real - z1.real * z2.imag) / denominator;
    return result;
}

// Функция для возведения комплексного числа в четвертую степень
ComplexNumber pow4ComplexNumber(ComplexNumber z) {
    ComplexNumber result;
    result.real = pow(z.real * z.real - z.imag * z.imag, 2);
    result.imag = 4.0 * z.real * z.imag * (z.real * z.real - z.imag * z.imag);
    return result;
}

// Функция для вычисления корня третьей степени из комплексного числа
ComplexNumber cbrtComplexNumber(ComplexNumber z) {
    double modulus = sqrt(z.real * z.real + z.imag * z.imag);
    double angle = atan2(z.imag, z.real) / 3.0;
    ComplexNumber result;
    result.real = modulus * cos(angle);
    result.imag = modulus * sin(angle);
    return result;
}

// Функция для вычисления корня уравнения Inx + (x + 1)^3 = 0 методом дихотомии
double dichotomicMethod(double a, double b, double epsilon) {
    double x1, x2, fx1, fx2;
    while (b - a > epsilon) {
        x1 = (a + b) / 2.0;
        x2 = b - x1;
        fx1 = log(x1) + pow(x1 + 1.0, 3.0);
        fx2 = log(x2) + pow(x2 + 1.0, 3.0);
        if (fx1 * fx2 < 0) {
            b = x2;
        } else {
            a = x1;
        }
    }
    return (a + b) / 2.0;
}

// Функция для вычисления корня уравнения Inx + (x + 1)^3 = 0 методом итераций
double iterationMethod(double x0, double epsilon) {
    double x1 = x0;
    while (abs(log(x1) + pow(x1 + 1.0, 3.0)) > epsilon) {
        x1 = x1 - (log(x1) + pow(x1 + 1.0, 3.0)) / (1.0 / x1 + 3.0 * pow(x1 + 1.0, 2.0));
    }
    return x1;
}

// Функция для вычисления корня уравнения Inx +
#include <iostream>
#include <cmath>

using namespace std;

// Функция для вычисления корня уравнения Inx + (x + 1)^3 = 0 методом хорд
double chordMethod(double a, double b, double epsilon) {
    double x1, x2, fx1, fx2;
    while (b - a > epsilon) {
        x1 = a + (b - a) * log(b) / (log(b) - log(a) + pow(b + 1.0, 3.0) - pow(a + 1.0, 3.0));
        x2 = b - (b - x1) * log(x1) / (log(x1) - log(a) + pow(x1 + 1.0, 3.0) - pow(a + 1.0, 3.0));
        fx1 = log(x1) + pow(x1 + 1.0, 3.0);
        fx2 = log(x2) + pow(x2 + 1.0, 3.0);
        if (fx1 * fx2 < 0) {
            b = x2;
        } else {
            a = x1;
        }
    }
    return (a + b) / 2.0;
}

// Функция для вычисления корня уравнения Inx + (x + 1)^3 = 0 методом Ньютона
double newtonMethod(double x0, double epsilon) {
    double x1 = x0;
    while (abs(log(x1) + pow(x1 + 1.0, 3.0)) > epsilon) {
        x1 = x1 - (log(x1) + pow(x1 + 1.0, 3.0)) / (1.0 / x1 + 3.0 * pow(x1 + 1.0, 2.0));
    }
    return x1;
}

int main() {
    // Комплексные числа
    ComplexNumber z1 = {2.0, 1.0};
    ComplexNumber z2 = {3.0, 1.0};
    ComplexNumber z3 = {1.0, 2.0};

    // Сложение комплексных чисел
    ComplexNumber sum = addComplexNumbers(z1, z2);
    cout << "Сумма: " << sum.real << " + " << sum.imag << "i" << endl;

    // Вычитание комплексных чисел
    ComplexNumber difference = subtractComplexNumbers(z1, z2);
    cout << "Разность: " << difference.real << " + " << difference.imag << "i" << endl;

    // Умножение комплексных чисел
    ComplexNumber product = multiplyComplexNumbers(z1, z2);
    cout << "Произведение: " << product.real << " + " << product.imag << "i" << endl;

    // Деление комплексных чисел
    ComplexNumber quotient = divideComplexNumbers(z1, z2);
    cout << "Частное: " << quotient.real << " + " << quotient.imag << "i" << endl;

    // Четвертая степень комплексного числа
    ComplexNumber power4 = pow4ComplexNumber(z3);
    cout << "Четвертая степень: " << power4.real << " + " << power4.imag << "i" << endl;

    // Корень третьей степени комплексного числа
    ComplexNumber cbrt = cbrtComplexNumber(z3);
    cout << "Корень третьей степени: " << cbrt.real << " + " << cbrt.imag << "i" << endl;

    // Корень уравнения методом дихотомии
    double rootDichotomy = dichotomicMethod(0.0, 1.0, 1e-6);
    cout << "Корень уравнения (метод дихотомии): " << rootDichotomy << endl;

    // Корень уравнения методом итераций
    double rootIteration = iterationMethod(0.5, 1e-6);
    cout << "Корень уравнения (метод итераций): " << rootIteration << endl;

    // Корень уравнения методом хорд
    double rootChord = chordMethod(0.0, 1.0, 1e-6

python
# Комплексные числа
class ComplexNumber:
    def init(self, real, imag):
        self.real = real
        self.imag = imag

    def add(self, other):
        if isinstance(other, ComplexNumber):
            return ComplexNumber(self.real + other.real, self.imag + other.imag)
        else:
            raise TypeError("Невозможно сложить комплексное число с {}".format(type(other)))

    def sub(self, other):
        if isinstance(other, ComplexNumber):
            return ComplexNumber(self.real - other.real, self.imag - other.imag)
        else:
            raise TypeError("Невозможно вычесть комплексное число из {}".format(type(other)))

    def mul(self, other):
        if isinstance(other, ComplexNumber):
            real = self.real * other.real - self.imag * other.imag
            imag = self.real * other.imag + self.imag * other.real
            return ComplexNumber(real, imag)
        else:
            raise TypeError("Невозможно умножить комплексное число на {}".format(type(other)))

    def truediv(self, other):
        if isinstance(other, ComplexNumber):
            denominator = other.real * other.real + other.imag * other.imag
            real = (self.real * other.real + self.imag * other.imag) / denominator
            imag = (self.imag * other.real - self.real * other.imag) / denominator
            return ComplexNumber(real, imag)
        else:
            raise TypeError("Невозможно разделить комплексное число на {}".format(type(other)))

    def abs(self):
        return math.sqrt(self.real * self.real + self.imag * self.imag)

    def str(self):
        return "{:.2f} + {:.2f}i".format(self.real, self.imag)

# Функции для работы с комплексными числами
def add_complex_numbers(z1, z2):
    """
    Сложение комплексных чисел.

    Args:
        z1 (ComplexNumber): первое комплексное число.
        z2 (ComplexNumber): второе комплексное число.

    Returns:
        ComplexNumber: сумма комплексных чисел.
    """
    return z1 + z2

def subtract_complex_numbers(z1, z2):
    """
    Вычитание комплексных чисел.

    Args:
        z1 (ComplexNumber): первое комплексное число.
        z2 (ComplexNumber): второе комплексное число.

    Returns:
        ComplexNumber: разница комплексных чисел.
    """
    return z1 - z2

def multiply_complex_numbers(z1, z2):
    """
    Умножение комплексных чисел.

    Args:
        z1 (ComplexNumber): первое комплексное число.
        z2 (ComplexNumber): второе комплексное число.

    Returns:
        ComplexNumber: произведение комплексных чисел.
    """
    return z1 * z2

def divide_complex_numbers(z1, z2):
    """
    Деление комплексных чисел.

    Args:
        z1 (ComplexNumber): первое комплексное число.
        z2 (ComplexNumber): второе комплексное число.

    Returns:
        ComplexNumber: частное комплексных чисел.
    """
    return z1 / z2

def pow4_complex_number(z):
    """
    Возведение комплексного числа в четвертую степень.

    Args:
        z (ComplexNumber): комплексное число.

    Returns:
        ComplexNumber: четвертая степень комплексного числа.
    """
    return z * z * z * z

def cbrt_complex_number(z):
    """
    Вычисление корня третьей степени из комплексного числа.

    Args:
        z (ComplexNumber): комплексное число.

    Returns:
        ComplexNumber: корень третьей степени из комплексного числа.
    """
    modulus = abs(z)
    angle = math.atan2(z.imag, z.real) / 3.0
    return ComplexNumber(modulus * math.cos(angle), modulus * math.sin(angle))

# Функции для поиска корня уравнения
def dichotomic_method(a, b, epsilon):
    """

import math

def equation(x):
    return math.log(x) + (x + 1) ** 3

def dichotomic_method(a, b, epsilon):
    """
    Метод дихотомии для поиска корня уравнения.

    Args:
        a (float): левая граница интервала.
        b (float): правая граница интервала.
        epsilon (float): точность вычислений.

    Returns:
        float: корень уравнения.
    """
    while b - a > epsilon:
        x1 = (a + b) / 2.0
        x2 = b - x1
        f1 = equation(x1)
        f2 = equation(x2)
        if f1 * f2 < 0:
            b = x2
        else:
            a = x1
    return (a + b) / 2.0

def iteration_method(x0, epsilon):
    """
    Метод итераций для поиска корня уравнения.

    Args:
        x0 (float): начальное приближение.
        epsilon (float): точность вычислений.

    Returns:
        float: корень уравнения.
    """
    x1 = x0
    while abs(equation(x1)) > epsilon:
        x1 = x1 - equation(x1) / (1.0 / x1 + 3.0 * (x1 + 1.0) ** 2)
    return x1

def chord_method(a, b, epsilon):
    """
    Метод хорд для поиска корня уравнения.

    Args:
        a (float): левая граница интервала.
        b (float): правая граница интервала.
        epsilon (float): точность вычислений.

    Returns:
        float: корень уравнения.
    """
    while b - a > epsilon:
        x1 = a + (b - a) * math.log(b) / (math.log(b) - math.log(a) + (b + 1)  3 - (a + 1)  3)
        x2 = b - (b - x1) * math.log(x1) / (math.log(x1) - math.log(a) + (x1 + 1)  3 - (a + 1)  3)
        f1 = equation(x1)
        f2 = equation(x2)
        if f1 * f2 < 0:
            b = x2
        else:
            a = x1
    return (a + b) / 2.0

def newton_method(x0, epsilon):
    """
    Метод Ньютона для поиска корня уравнения.

    Args:
        x0 (float): начальное приближение.
        epsilon (float): точность вычислений.

    Returns:
        float: корень уравнения.
    """
    x1 = x0
    while abs(equation(x1)) > epsilon:
        x1 = x1 - equation(x1) / (1.0 / x1 + 3.0 * (x1 + 1.0) ** 2)
    return x1

if name == "main":
    # Заданное уравнение
    equation = lambda x: math.log(x) + (x + 1) ** 3

    # Корень уравнения методом дихотомии
    root_dichotomic = dichotomic_method(0.0, 1.0, 1e-6)
    print("Корень уравнения (метод дихотомии):", root_dichotomic)

    # Корень уравнения методом итераций
    root_iteration = iteration_method(0.5, 1e-6)
    print("Корень уравнения (метод итераций):", root_iteration)

    # Корень уравнения методом хорд
    root_chord = chord_method(0.0, 1.0, 1e-6)
    print("Корень уравнения (метод хорд):", root_chord)

    # Корень уравнения методом Ньютона
    root_newton = newton_method(0.5, 1e-6)
    print("Корень уравнения (метод Ньютона):", root_newton)


