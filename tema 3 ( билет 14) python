1) import numpy as np

def rectangle_method(a, b, n, f):
  """
  Вычисляет значение определенного интеграла методом прямоугольников.

  Args:
    a: Нижний предел интегрирования.
    b: Верхний предел интегрирования.
    n: Количество разбиений отрезка интегрирования.
    f: Функция, под интегралом.

  Returns:
    Численное значение интеграла.
  """
  h = (b - a) / n
  x = np.linspace(a, b, n + 1)
  y = f(x)
  return h * np.sum(y[:-1])

def trapeze_method(a, b, n, f):
  """
  Вычисляет значение определенного интеграла методом трапеций.

  Args:
    a: Нижний предел интегрирования.
    b: Верхний предел интегрирования.
    n: Количество разбиений отрезка интегрирования.
    f: Функция, под интегралом.

  Returns:
    Численное значение интеграла.
  """
  h = (b - a) / n
  x = np.linspace(a, b, n + 1)
  y = f(x)
  return h / 2 * (y[0] + 2 * np.sum(y[1:-1]) + y[-1])

def simpson_method(a, b, n, f):
  """
  Вычисляет значение определенного интеграла методом Симпсона.

  Args:
    a: Нижний предел интегрирования.
    b: Верхний предел интегрирования.
    n: Количество разбиений отрезка интегрирования.
    f: Функция, под интегралом.

  Returns:
    Численное значение интеграла.
  """
  h = (b - a) / n
  x = np.linspace(a, b, n + 1)
  y = f(x)
  return h / 6 * (y[0] + y[-1] + 4 * np.sum(y[1:-1]) + 2 * np.sum(y[2::2]))

# Функция под интегралом
def f(x):
  return x  4 / (14 + x  2) ** 0.5

# Вычисление интеграла методом прямоугольников
a = 0
b = 1
n = 1000
I_rectangle = rectangle_method(a, b, n, f)
print("Метод прямоугольников:", I_rectangle)

# Вычисление интеграла методом трапеций
I_trapeze = trapeze_method(a, b, n, f)
print("Метод трапеций:", I_trapeze)

# Вычисление интеграла методом Симпсона
I_simpson = simpson_method(a, b, n, f)
print("Метод Симпсона:", I_simpson)

2) import numpy as np

def rectangle_method_inf(a, b, n, f):
  """
  Вычисляет значение неопределенного интеграла методом прямоугольников.

  Args:
    a: Нижний предел интегрирования.
    b: Верхний предел интегрирования.
    n: Количество разбиений отрезка интегрирования.
    f: Функция, под интегралом.

  Returns:
    Численное значение интеграла.
  """
  h = (b - a) / n
  x = np.linspace(a, b, n + 1)
  y = f(x)
  return h * np.sum(y[:-1])

def trapeze_method_inf(a, b, n, f):
  """
  Вычисляет значение неопределенного интеграла методом трапеций.

  Args:
    a: Нижний предел интегрирования.
    b: Верхний предел интегрирования.
    n: Количество разбиений отрезка интегрирования.
    f: Функция, под интегралом.

  Returns:
    Численное значение интеграла.
  """
  h = (b - a) / n
  x = np.linspace(a, b, n + 1)
  y = f(x)
  return h / 2 * (y[0] + 2 * np.sum(y[1:-1]) + y[-1])

def simpson_method_inf(a, b, n, f):
  """
  Вычисляет значение неопределенного интеграла методом Симпсона.

  Args:
    a: Нижний предел интегрирования.
    b: Верхний предел интегрирования.
    n: Количество разбиений отрезка интегрирования.
    f: Функция, под интегралом.

  Returns:
    Численное значение интеграла.
  """
  h = (b - a) / n
  x = np.linspace(a, b, n + 1)
  y = f(x)
  return h / 6 * (y[0] + y[-1] + 4 * np.sum(y[1:-1]) + 2 * np.sum(y[2::2]))

# Функция под интегралом
def f(x):
  return 8 * np.exp(-2 * x) * np.sin(14 * x)

# Вычисление интеграла методом прямоугольников
a = 0
b = 1
n = 1000
I_rectangle_inf = rectangle_method_inf(a, b, n, f)
print("Метод прямоугольников:", I_rectangle_inf)

# Вычисление интеграла методом трапеций
I_trapeze_inf = trapeze_method_inf(a, b, n, f)
print("Метод трапеций:", I_trapeze_inf)

# Вычисление интеграла методом Симпсона
I_simpson_inf = simpson_method_inf(a, b, n, f)
print("Метод Симпсона:", I_simpson_inf)
3) import numpy as np

def series_sum(n, f):
  """
  Вычисляет сумму числового ряда.

  Args:
    n: Количество членов ряда.
    f: Функция, определяющая n-й член ряда.

  Returns:
    Сумма ряда.
  """
  s = 0
  for i in range(n):
    s += f(i)
  return s

# Функция, определяющая n-й член ряда
def f(n):
  return (-1)  n * (2 * n - 1) / ((2 * n)  3 - 1)

# Вычисление суммы ряда
n = 1000
S = series_sum(n, f)
print("Сумма ряда:", S)
4) 
import numpy as np

def series_sum_func(n, x):
  """
  Вычисляет сумму функционального ряда.

  Args:
    n: Количество членов ряда.
    x: Значение аргумента, для которого вычисляется сумма.

  Returns:
    Сумма ряда.
  """
  s = 0
  for k in range(1, n + 1):
    s += (-1)  (k - 1) * np.sin(k * x) + 14 + k  2
  return s

def trapeze_method_inf(a, b, n, f, x):
  """
  Вычисляет значение неопределенного интеграла методом трапеций.

  Args:
    a: Нижний предел интегрирования.
    b: Верхний предел интегрирования.
    n: Количество разбиений отрезка интегрирования.
    f: Функция, под интегралом.
    x: Значение аргумента, для которого вычисляется интеграл.

  Returns:
    Численное значение интеграла.
  """
  h = (b - a) / n
  x_arr = np.linspace(a, b, n + 1)
  y_arr = f(x_arr, x)
  return h / 2 * (y_arr[0] + 2 * np.sum(y_arr[1:-1]) + y_arr[-1])

# Вычисление суммы ряда
x = 1
n = 1000
S_func = series_sum_func(n, x)

# Вычисление интеграла методом трапеций
a = 0
b = 1
I_trapeze_inf = trapeze_method_inf(a, b, n, series_sum_func, x)

# Вычисление суммы ряда
S = I_trapeze_inf - 14 * x

print("Сумма ряда:", S)
